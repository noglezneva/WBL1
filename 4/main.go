package main

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
)

func main() {
	//кол-во воркеров
	var num int
	//канал для коммуникации между воркерами
	c := make(chan int)

	fmt.Print("Введите количество воркеров - ")
	fmt.Scanln(&num)

	//запускает в новой горутине функцию writer, которая
	// будет записывать данные в канал
	go writer(c)

	//Создание указанного пользователем количества воркеров
	//Для каждого воркера запускается функция reader(c) в отдельной горутине
	for i := 0; i < num; i++ {
		go reader(c)
	}

	//Завершение работы по ctrl + c
	ctrl := make(chan os.Signal) // канал для получения сигналов от ОС
	//устанавливает обработчик сигналов для канала ctrl
	signal.Notify(ctrl, os.Interrupt, syscall.SIGTERM)
	// ожидает получения сигнала завершения работы
	<-ctrl
	fmt.Println("exit after ctrl c")
	os.Exit(1) // немедленное завершение работы с кодом выхода 1
}

// Функция для записи данных в канал
func writer(c chan int) {
	i := 0
	// бесконечно увеличивает значение переменной i и отправляет его в канал
	for {
		c <- i
		i++
	}
}

// Функция, которая читает данные из канала c и выводит их на экзан
func reader(c chan int) {
	for val := range c {
		fmt.Println(val)
	}
}

// В данном коде использован подход, основанный на принятии сигнала os.Interrupt (Ctrl+C) или syscall.SIGTERM
// для остановки работы программы. Когда сигнал получен, программа выводит сообщение "exit after ctrl c" и немедленно
// завершается с кодом выхода 1. Это приводит к остановке всех горутин, включая горутину writer и горутины reader воркеров.
// Программа немедленно завершает работу с помощью os.Exit(1), что позволяет гарантировать прерывание работы всех горутин, 
// в том числе воркеров, без необходимости ожидания завершения.