// 11. Что выведет данная программа и почему?
package main

import (
	"fmt"
	"sync"
)

// func main() {
// 	wg := sync.WaitGroup{}
// 	for i := 0; i < 5; i++ {
// 		wg.Add(1)
// 		go func(wg sync.WaitGroup, i int) {
// 			fmt.Println(i)
// 			wg.Done()
// 		}(wg, i)
// 	}
// 	wg.Wait()
// 	fmt.Println("exit")
// }

//вывод
//
// 1) Данный код создает анонимную горутину, в которой принимаются параметры wg и i.
// 2) Внутри анонимной горутины выводится значение i, и затем вызывается wg.Done().
//    Однако wg передается по значению, поэтому вызов wg.Done() уменьшает копию WaitGroup, а не оригинальный WaitGroup, созданный в main().
// 3) После каждого вызова go func, создается новая анонимная горутина, которая работает асинхронно.

// После того как создаются все анонимные горутины, главная горутина достигает wg.Wait(), ожидая,
// что все анонимные горутины закончат свою работу и вызовут wg.Done(). Однако, так как каждая анонимная горутина
// уменьшает копию WaitGroup, а не оригинальный WaitGroup, счетчик остается ненулевым.

// Это приводит к deadlock (зависанию), потому что wg.Wait() ожидает, что счетчик станет нулевым,
// но этого не происходит из-за неверного использования WaitGroup.

// Чтобы исправить это, нужно передать WaitGroup и i по указателю в анонимную горутину,
// чтобы изменения в анонимных горутинах влияли на оригинальные переменные.

// исправленный вариант кода
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(&wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
